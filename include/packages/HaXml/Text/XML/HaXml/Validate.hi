interface Text.XML.HaXml.Validate where {

{-# NEED #-}
instance Text.XML.HaXml.Verbatim.Verbatim Text.XML.HaXml.Types.Reference;

{-# NEED #-}
instance Text.XML.HaXml.Verbatim.Verbatim (Text.XML.HaXml.Types.Content a);

{-# NEED #-}
instance Text.XML.HaXml.Verbatim.Verbatim (Text.XML.HaXml.Types.Element a);

{-# NEED #-}
instance Control.Monad.Fix.MonadFix NHC.Internal.IO;

{-# NEED #-}
instance Control.Applicative.Applicative NHC.Internal.IO;

{-# NEED #-}
instance Ix.Ix IO.SeekMode;

{-# NEED #-}
instance Ix.Ix IO.IOMode;

{-# NEED #-}
instance Data.Traversable.Traversable (Data.Map.Map a);

{-# NEED #-}
instance Data.Typeable.Typeable2 Data.Map.Map;

{-# NEED #-}
instance Data.Foldable.Foldable (Data.Map.Map a);

{-# NEED #-}
instance Data.Typeable.Typeable1 Ratio.Ratio;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.Internal.IO;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable1 (Data.Map.Map a);

{-# NEED #-}
instance Data.Monoid.Monoid Data.ByteString.Lazy.Internal.ByteString;

{-# NEED #-}
instance Data.Monoid.Monoid Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance (Prelude.Ord a) => Data.Monoid.Monoid (Data.Map.Map a b);

{-# NEED #-}
instance (Text.XML.HaXml.XmlContent.Parser.XmlContent a) => Text.XML.HaXml.XmlContent.Parser.XmlContent (Text.XML.HaXml.XmlContent.Parser.List1 a);

{-# NEED #-}
instance Text.XML.HaXml.XmlContent.Parser.XmlContent Text.XML.HaXml.XmlContent.Parser.ANYContent;

{-# NEED #-}
instance Text.XML.HaXml.XmlContent.Parser.XmlContent Prelude.Char;

{-# NEED #-}
instance (Text.XML.HaXml.XmlContent.Parser.XmlContent a,Text.XML.HaXml.XmlContent.Parser.XmlContent b) => Text.XML.HaXml.XmlContent.Parser.XmlContent (a,b);

{-# NEED #-}
instance (Text.XML.HaXml.XmlContent.Parser.XmlContent a) => Text.XML.HaXml.XmlContent.Parser.XmlContent [a];

{-# NEED #-}
instance (Text.XML.HaXml.XmlContent.Parser.XmlContent a) => Text.XML.HaXml.XmlContent.Parser.XmlContent (Prelude.Maybe a);

{-# NEED #-}
instance (Text.XML.HaXml.TypeMapping.HTypeable a) => Text.XML.HaXml.TypeMapping.HTypeable (Text.XML.HaXml.XmlContent.Parser.List1 a);

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable Text.XML.HaXml.XmlContent.Parser.ANYContent;

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable ();

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable Prelude.Integer;

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable Prelude.Float;

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable Prelude.Double;

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable Prelude.Int;

{-# NEED #-}
instance (Text.XML.HaXml.TypeMapping.HTypeable a,Text.XML.HaXml.TypeMapping.HTypeable b) => Text.XML.HaXml.TypeMapping.HTypeable (Prelude.Either a b);

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable Prelude.Char;

{-# NEED #-}
instance (Text.XML.HaXml.TypeMapping.HTypeable a,Text.XML.HaXml.TypeMapping.HTypeable b) => Text.XML.HaXml.TypeMapping.HTypeable (a,b);

{-# NEED #-}
instance (Text.XML.HaXml.TypeMapping.HTypeable a) => Text.XML.HaXml.TypeMapping.HTypeable [a];

{-# NEED #-}
instance Text.XML.HaXml.TypeMapping.HTypeable Prelude.Bool;

{-# NEED #-}
instance (Text.XML.HaXml.TypeMapping.HTypeable a) => Text.XML.HaXml.TypeMapping.HTypeable (Prelude.Maybe a);

{-# NEED #-}
instance Prelude.Bounded IO.SeekMode;

{-# NEED #-}
instance Prelude.Bounded IO.IOMode;

{-# NEED #-}
instance Text.ParserCombinators.Poly.Base.PolyParse (Text.ParserCombinators.Poly.State.Parser a b);

{-# NEED #-}
instance Text.ParserCombinators.Poly.Base.PolyParse (Text.ParserCombinators.Poly.Plain.Parser a);

{-# NEED #-}
instance Text.ParserCombinators.Poly.Base.PolyParse Prelude.[];

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Enum IO.SeekMode;

{-# NEED #-}
instance Prelude.Enum IO.IOMode;

{-# NEED #-}
instance Prelude.Enum NHC.DErrNo.ErrNo;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Monad (Text.ParserCombinators.Poly.State.Parser a b);

{-# NEED #-}
instance Prelude.Monad (Text.ParserCombinators.Poly.Plain.Parser a);

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Functor (Text.ParserCombinators.Poly.State.Parser a b);

{-# NEED #-}
instance Prelude.Functor (Text.ParserCombinators.Poly.State.Result a b);

{-# NEED #-}
instance Prelude.Functor (Text.ParserCombinators.Poly.Plain.Parser a);

{-# NEED #-}
instance Prelude.Functor (Text.ParserCombinators.Poly.Plain.Result a);

{-# NEED #-}
instance Prelude.Functor Text.XML.HaXml.Types.Content;

{-# NEED #-}
instance Prelude.Functor Text.XML.HaXml.Types.Element;

{-# NEED #-}
instance Prelude.Functor Text.XML.HaXml.Types.Document;

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Functor (Data.Map.Map a);

{-# NEED #-}
instance Prelude.Eq IO.HandlePosn;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Lex.Where;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Lex.TokenT;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Lex.Special;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Lex.Section;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Posn.Posn;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.TypeMapping.Constr;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.TypeMapping.HType;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Text.XML.HaXml.XmlContent.Parser.List1 a);

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.XmlContent.Parser.ANYContent;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Text.XML.HaXml.XmlContent.Parser.Defaultable a);

{-# NEED #-}
instance Prelude.Eq IO.BufferMode;

{-# NEED #-}
instance Prelude.Eq DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Eq Data.ByteString.Lazy.Internal.ByteString;

{-# NEED #-}
instance Prelude.Eq Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance Prelude.Eq IO.SeekMode;

{-# NEED #-}
instance Prelude.Eq IO.IOMode;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.QName;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.SystemLiteral;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.PubidLiteral;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.EV;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.EntityValue;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.AttValue;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.Namespace;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ExternalID;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.PEDef;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.Reference;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.EncodingDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.PublicID;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.NotationDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ExtPE;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Text.XML.HaXml.Types.ExtParsedEnt a);

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.TextDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.NDataDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.EntityDef;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.PEDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.GEDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.EntityDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.IgnoreSectContents;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.Ignore;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ConditionalSect;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.FIXED;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.DefaultDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.EnumeratedType;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.TokenizedType;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.AttType;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.AttDef;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.AttListDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.Mixed;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.Modifier;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.CP;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ContentSpec;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ElementDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ElemTag;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ExtSubsetDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.ExtSubset;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.MarkupDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.DocTypeDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.Misc;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.XMLDecl;

{-# NEED #-}
instance Prelude.Eq Text.XML.HaXml.Types.Prolog;

{-# NEED #-}
instance Prelude.Eq NHC.DErrNo.ErrNo;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Text.XML.HaXml.Types.Content a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Text.XML.HaXml.Types.Element a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Text.XML.HaXml.Types.Document a);

{-# NEED #-}
instance Prelude.Eq IO.Handle;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Eq a,Prelude.Eq b) => Prelude.Eq (Data.Map.Map a b);

{-# NEED #-}
instance Prelude.Show Text.PrettyPrint.HughesPJ.Doc;

{-# NEED #-}
instance Prelude.Show IO.HandlePosn;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Lex.TokenT;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Lex.Special;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Lex.Section;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Posn.Posn;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.TypeMapping.Constr;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.TypeMapping.HType;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Text.XML.HaXml.XmlContent.Parser.List1 a);

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.XmlContent.Parser.ANYContent;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Text.XML.HaXml.XmlContent.Parser.Defaultable a);

{-# NEED #-}
instance Prelude.Show IO.BufferMode;

{-# NEED #-}
instance Prelude.Show DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Show Data.ByteString.Lazy.Internal.ByteString;

{-# NEED #-}
instance Prelude.Show Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance Prelude.Show IO.SeekMode;

{-# NEED #-}
instance Prelude.Show IO.IOMode;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.QName;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.SystemLiteral;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.PubidLiteral;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.EV;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.EntityValue;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.AttValue;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.Namespace;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.ExternalID;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.PEDef;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.Reference;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.Modifier;

{-# NEED #-}
instance Prelude.Show Text.XML.HaXml.Types.CP;

{-# NEED #-}
instance Prelude.Show NHC.DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Show IO.Handle;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);

{-# NEED #-}
instance (Prelude.Show a,Prelude.Show b) => Prelude.Show (Data.Map.Map a b);

{-# NEED #-}
instance Prelude.Read IO.BufferMode;

{-# NEED #-}
instance Prelude.Read Data.ByteString.Lazy.Internal.ByteString;

{-# NEED #-}
instance Prelude.Read Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance Prelude.Read IO.SeekMode;

{-# NEED #-}
instance Prelude.Read IO.IOMode;

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Read a,Prelude.Read b) => Prelude.Read (Data.Map.Map a b);

{-# NEED #-}
instance Data.Typeable.Typeable ();

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Ordering;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Integer;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Float;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Double;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Int;

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (Prelude.Either a b);

{-# NEED #-}
instance Data.Typeable.Typeable IO.Handle;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Ratio.Ratio a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.Internal.IO a);

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Char;

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (Data.Map.Map a b);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable [a];

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Bool;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Prelude.Maybe a);

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (a -> b);

{-# NEED #-}
instance Prelude.Ord IO.BufferMode;

{-# NEED #-}
instance Prelude.Ord Data.ByteString.Lazy.Internal.ByteString;

{-# NEED #-}
instance Prelude.Ord Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance Prelude.Ord IO.SeekMode;

{-# NEED #-}
instance Prelude.Ord IO.IOMode;

{-# NEED #-}
instance Prelude.Ord Text.XML.HaXml.Types.QName;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Ord a,Prelude.Ord b) => Prelude.Ord (Data.Map.Map a b);
interface Text.XML.HaXml.XmlContent.Parser
{-# NEED XmlContent #-}
class (Text.XML.HaXml.TypeMapping.HTypeable a) => XmlContent a;
interface Text.XML.HaXml.TypeMapping
{-# NEED HTypeable #-}
class HTypeable a;
interface Text.ParserCombinators.Poly.State
{-# NEED Parser #-}
newtype {-#  #-} Parser a b c;

{-# NEED Result #-}
data Result a b c;
interface Text.ParserCombinators.Poly.Plain
{-# NEED Parser #-}
newtype {-#  #-} Parser a b;

{-# NEED Result #-}
data Result a b;
interface Text.XML.HaXml.Lex
{-# NEED Where #-}
data Where;
interface Text.XML.HaXml.Types
{-# NEED ExtPE #-}
data ExtPE;

{-# NEED ExtParsedEnt #-}
data ExtParsedEnt a;

{-# NEED ElemTag #-}
data ElemTag;

{-# NEED ExtSubset #-}
data ExtSubset;

{-# NEED ExtSubsetDecl ConditionalSect IncludeSect #-}
data ExtSubsetDecl;
data ConditionalSect;
type {-# 13 #-} IncludeSect = [ExtSubsetDecl];

{-# NEED IgnoreSect #-}
type {-# 14 #-} IgnoreSect = [IgnoreSectContents];

{-# NEED IgnoreSectContents #-}
data IgnoreSectContents;

{-# NEED Ignore #-}
data Ignore;

{-# NEED TextDecl #-}
data TextDecl;

{-# NEED Document #-}
data Document a;

{-# NEED SymTab #-}
type {-# 2 #-} SymTab a = [(Prelude.String,a)];

{-# NEED Prolog #-}
data Prolog;

{-# NEED XMLDecl #-}
data XMLDecl;

{-# NEED SDDecl #-}
type {-# 5 #-} SDDecl = Prelude.Bool;

{-# NEED EncodingDecl #-}
newtype {-#  #-} EncodingDecl;

{-# NEED VersionInfo #-}
type {-# 6 #-} VersionInfo = Prelude.String;
interface Text.PrettyPrint.HughesPJ
{-# NEED Doc #-}
data Doc;
interface IO
{-# NEED HandlePosn #-}
data HandlePosn;
interface Text.XML.HaXml.Lex
{-# NEED TokenT #-}
data TokenT;

{-# NEED Special #-}
data Special;

{-# NEED Section #-}
data Section;
interface Text.XML.HaXml.Posn
{-# NEED Posn #-}
data Posn;
interface Text.XML.HaXml.TypeMapping
{-# NEED Constr #-}
data Constr;

{-# NEED HType #-}
data HType;
interface Text.XML.HaXml.XmlContent.Parser
{-# NEED List1 #-}
data List1 a;

{-# NEED ANYContent #-}
data ANYContent;

{-# NEED Defaultable #-}
data Defaultable a;
interface DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;
interface NHC.DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface NHC.Internal
{-# NEED World #-}
data World;
interface Data.Typeable
{-# NEED Typeable #-}
class Typeable a;
interface IO
{-# NEED BufferMode #-}
data BufferMode;
interface Data.ByteString.Lazy.Internal
{-# NEED ByteString #-}
data ByteString;
interface Data.ByteString.Internal
{-# NEED ByteString #-}
data ByteString;
interface IO
{-# NEED SeekMode #-}
data SeekMode;

{-# NEED IOMode #-}
data IOMode;
interface Ratio
{-# NEED Ratio #-}
data Ratio a;
interface Data.Map
{-# NEED Map #-}
data Map a b;
interface ! Text.XML.HaXml.Validate
{-# NEED partialValidate #-}
partialValidate{-# 2 #-}::(Text.XML.HaXml.Types.DocTypeDecl -> ((Text.XML.HaXml.Types.Element a) -> [Prelude.String]));

{-# NEED validate #-}
validate{-# 2 #-}::(Text.XML.HaXml.Types.DocTypeDecl -> ((Text.XML.HaXml.Types.Element a) -> [Prelude.String]));
interface Text.XML.HaXml.Types
{-# NEED Element Content #-}
data Element a;
data Content a;

{-# NEED CharData #-}
type {-# 20 #-} CharData = Prelude.String;

{-# NEED Attribute #-}
type {-# 8 #-} Attribute = (QName,AttValue);

{-# NEED DocTypeDecl #-}
data DocTypeDecl;

{-# NEED MarkupDecl #-}
data MarkupDecl;

{-# NEED Misc #-}
data Misc;

{-# NEED ProcessingInstruction #-}
type {-# 4 #-} ProcessingInstruction = (PITarget,Prelude.String);

{-# NEED PITarget #-}
type {-# 3 #-} PITarget = Prelude.String;

{-# NEED Comment #-}
type {-# 7 #-} Comment = Prelude.String;

{-# NEED NotationDecl #-}
data NotationDecl;

{-# NEED PublicID #-}
newtype {-#  #-} PublicID;

{-# NEED EntityDecl #-}
data EntityDecl;

{-# NEED PEDecl #-}
data PEDecl;

{-# NEED PEDef #-}
data PEDef;

{-# NEED GEDecl #-}
data GEDecl;

{-# NEED EntityDef #-}
data EntityDef;

{-# NEED NDataDecl #-}
newtype {-#  #-} NDataDecl;

{-# NEED EntityValue #-}
data EntityValue;

{-# NEED EV #-}
data EV;

{-# NEED AttListDecl #-}
data AttListDecl;

{-# NEED AttDef #-}
data AttDef;

{-# NEED DefaultDecl #-}
data DefaultDecl;

{-# NEED FIXED #-}
data FIXED;

{-# NEED AttValue #-}
data AttValue;

{-# NEED Reference #-}
data Reference;

{-# NEED CharRef #-}
type {-# 16 #-} CharRef = Prelude.Int;

{-# NEED EntityRef #-}
type {-# 15 #-} EntityRef = Name;

{-# NEED AttType #-}
data AttType;

{-# NEED EnumeratedType #-}
data EnumeratedType;

{-# NEED Enumeration #-}
type {-# 12 #-} Enumeration = [NmToken];

{-# NEED NmToken #-}
type {-# 11 #-} NmToken = Prelude.String;

{-# NEED NotationType #-}
type {-# 10 #-} NotationType = [Name];

{-# NEED TokenizedType #-}
data TokenizedType;

{-# NEED ElementDecl #-}
data ElementDecl;

{-# NEED ContentSpec #-}
data ContentSpec;

{-# NEED CP #-}
data CP;

{-# NEED Modifier #-}
data Modifier;

{-# NEED Mixed #-}
data Mixed;

{-# NEED ExternalID #-}
data ExternalID;

{-# NEED PubidLiteral #-}
newtype {-#  #-} PubidLiteral;

{-# NEED SystemLiteral #-}
newtype {-#  #-} SystemLiteral;

{-# NEED QName #-}
data QName;

{-# NEED Namespace #-}
data Namespace;

{-# NEED Name #-}
type {-# 9 #-} Name = Prelude.String;
}
