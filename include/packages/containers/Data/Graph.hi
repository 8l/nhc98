interface Data.Graph where {

{-# NEED #-}
instance Data.Monoid.Monoid Data.IntSet.IntSet;

{-# NEED #-}
instance Control.Monad.Fix.MonadFix NHC.Internal.IO;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word32;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word64;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word16;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word8;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int8;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int16;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int32;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int64;

{-# NEED #-}
instance Data.Typeable.Typeable2 Array.Array;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CInt;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word32;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word64;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word16;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word8;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int8;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int16;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int32;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int64;

{-# NEED #-}
instance NHC.FFI.Storable (NHC.FFI.Ptr a);

{-# NEED #-}
instance NHC.FFI.Storable (NHC.FFI.FunPtr a);

{-# NEED #-}
instance NHC.FFI.Storable (NHC.FFI.StablePtr a);

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.Internal.IO;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable1 (Array.Array a);

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.FFI.Ptr;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.FFI.FunPtr;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.FFI.StablePtr;

{-# NEED #-}
instance Data.Typeable.Typeable1 Ratio.Ratio;

{-# NEED #-}
instance Data.Typeable.Typeable1 Data.Tree.Tree;

{-# NEED #-}
instance Control.Applicative.Applicative NHC.Internal.IO;

{-# NEED #-}
instance Control.Applicative.Applicative Data.Tree.Tree;

{-# NEED #-}
instance Data.Traversable.Traversable Data.Tree.Tree;

{-# NEED #-}
instance Data.Traversable.Traversable Data.Sequence.Node;

{-# NEED #-}
instance Data.Foldable.Foldable Data.Tree.Tree;

{-# NEED #-}
instance Data.Foldable.Foldable Data.Sequence.Node;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Bounded Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Bounded IO.IOMode;

{-# NEED #-}
instance Prelude.Bounded IO.SeekMode;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int64;

{-# NEED #-}
instance Ix.Ix Data.Char.GeneralCategory;

{-# NEED #-}
instance Ix.Ix IO.IOMode;

{-# NEED #-}
instance Ix.Ix IO.SeekMode;

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b) => Ix.Ix (a,b);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c) => Ix.Ix (a,b,c);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d) => Ix.Ix (a,b,c,d);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e) => Ix.Ix (a,b,c,d,e);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f) => Ix.Ix (a,b,c,d,e,f);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g) => Ix.Ix (a,b,c,d,e,f,g);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h) => Ix.Ix (a,b,c,d,e,f,g,h);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i) => Ix.Ix (a,b,c,d,e,f,g,h,i);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j) => Ix.Ix (a,b,c,d,e,f,g,h,i,j);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m,Ix.Ix n,Ix.Ix o) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word32;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word64;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word16;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word8;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int8;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int16;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int32;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int64;

{-# NEED #-}
instance Ix.Ix Prelude.Ordering;

{-# NEED #-}
instance Ix.Ix Prelude.Integer;

{-# NEED #-}
instance Ix.Ix Prelude.Char;

{-# NEED #-}
instance Ix.Ix Prelude.Bool;

{-# NEED #-}
instance Ix.Ix Prelude.Int;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Num NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int64;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Real NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int64;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Enum Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Enum IO.IOMode;

{-# NEED #-}
instance Prelude.Enum IO.SeekMode;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Enum (NHC.FFI.Ptr a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Ord (NHC.FFI.ForeignPtr a);

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Ord IO.BufferMode;

{-# NEED #-}
instance Prelude.Ord Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Ord IO.IOMode;

{-# NEED #-}
instance Prelude.Ord IO.SeekMode;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Ord Data.IntSet.IntSet;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Ord b) => Prelude.Ord (Array.Array a b);

{-# NEED #-}
instance Prelude.Ord (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Ord (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int64;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word32;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word64;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word16;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word8;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int8;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int16;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int32;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int64;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Ordering;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Integer;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Char;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Bool;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Int;

{-# NEED #-}
instance Data.Typeable.Typeable Data.Typeable.TyCon;

{-# NEED #-}
instance Data.Typeable.Typeable Data.Typeable.TypeRep;

{-# NEED #-}
instance Data.Typeable.Typeable IO.Handle;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Float;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Double;

{-# NEED #-}
instance Data.Typeable.Typeable ();

{-# NEED #-}
instance Data.Typeable.Typeable Data.IntSet.IntSet;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.Internal.IO a);

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (Array.Array a b);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.FFI.Ptr a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.FFI.StablePtr a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Ratio.Ratio a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Data.Tree.Tree a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable [a];

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Prelude.Maybe a);

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (a -> b);

{-# NEED #-}
instance Prelude.Read NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Read IO.BufferMode;

{-# NEED #-}
instance Prelude.Read Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Read IO.IOMode;

{-# NEED #-}
instance Prelude.Read IO.SeekMode;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Read Data.IntSet.IntSet;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Read a,Prelude.Read b) => Prelude.Read (Array.Array a b);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Tree.Tree a);

{-# NEED #-}
instance Prelude.Eq DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.KeyPr;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.Key;

{-# NEED #-}
instance Prelude.Eq Data.HashTable.HashData;

{-# NEED #-}
instance Prelude.Eq Data.HashTable.Inserts;

{-# NEED #-}
instance Prelude.Eq IO.HandlePosn;

{-# NEED #-}
instance Prelude.Eq (NHC.FFI.ForeignPtr a);

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Eq IO.BufferMode;

{-# NEED #-}
instance Prelude.Eq Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Eq IO.IOMode;

{-# NEED #-}
instance Prelude.Eq IO.SeekMode;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.TyCon;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.TypeRep;

{-# NEED #-}
instance Prelude.Eq IO.Handle;

{-# NEED #-}
instance Prelude.Eq Data.IntSet.IntSet;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Eq b) => Prelude.Eq (Array.Array a b);

{-# NEED #-}
instance Prelude.Eq (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Eq (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Tree.Tree a);

{-# NEED #-}
instance Prelude.Show DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Show Data.HashTable.HashData;

{-# NEED #-}
instance Prelude.Show IO.HandlePosn;

{-# NEED #-}
instance Prelude.Show (NHC.FFI.ForeignPtr a);

{-# NEED #-}
instance Prelude.Show NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Show IO.BufferMode;

{-# NEED #-}
instance Prelude.Show Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Show IO.IOMode;

{-# NEED #-}
instance Prelude.Show IO.SeekMode;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Show Data.Typeable.TyCon;

{-# NEED #-}
instance Prelude.Show Data.Typeable.TypeRep;

{-# NEED #-}
instance Prelude.Show IO.Handle;

{-# NEED #-}
instance Prelude.Show Data.IntSet.IntSet;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Show a,Prelude.Show b) => Prelude.Show (Array.Array a b);

{-# NEED #-}
instance Prelude.Show (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Show (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Tree.Tree a);

{-# NEED #-}
instance Prelude.Monad (SetM a);

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Monad Data.Tree.Tree;

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance (Ix.Ix a) => Prelude.Functor (Array.Array a);

{-# NEED #-}
instance Prelude.Functor Data.Tree.Tree;

{-# NEED #-}
instance Prelude.Functor Data.Sequence.Node;

{-# NEED #-}
instance Data.Sequence.Sized (Data.Sequence.Node a);
interface NHC.FFI
{-# NEED StablePtr #-}
data StablePtr a;
interface Data.Typeable
{-# NEED Typeable #-}
class Typeable a;

{-# NEED KeyPr #-}
data KeyPr;

{-# NEED Key #-}
newtype {-#  #-} Key;
interface Data.HashTable
{-# NEED Inserts #-}
data Inserts;
interface DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface Data.HashTable
{-# NEED HashData #-}
data HashData;
interface IO
{-# NEED HandlePosn #-}
data HandlePosn;
interface NHC.FFI
{-# NEED ForeignPtr #-}
data ForeignPtr a;

{-# NEED CInt #-}
newtype {-#  #-} CInt;
interface IO
{-# NEED BufferMode #-}
data BufferMode;
interface Data.Char
{-# NEED GeneralCategory #-}
data GeneralCategory;
interface IO
{-# NEED IOMode #-}
data IOMode;

{-# NEED SeekMode #-}
data SeekMode;
interface NHC.FFI
{-# NEED Word32 #-}
data Word32;

{-# NEED Word64 #-}
data Word64;

{-# NEED Word16 #-}
data Word16;

{-# NEED Word8 #-}
data Word8;

{-# NEED Int8 #-}
data Int8;

{-# NEED Int16 #-}
data Int16;

{-# NEED Int32 #-}
data Int32;

{-# NEED Int64 #-}
data Int64;
interface Data.Typeable
{-# NEED TyCon #-}
data TyCon;

{-# NEED TypeRep #-}
data TypeRep;
interface IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface NHC.FFI
{-# NEED Ptr #-}
data Ptr a;

{-# NEED FunPtr #-}
data FunPtr a;
interface Ratio
{-# NEED Ratio #-}
data (Prelude.Integral a) => Ratio a;
interface Data.Graph
{-# NEED SetM #-}
newtype {-#  #-} SetM a b;
interface Data.IntSet
{-# NEED IntSet #-}
data IntSet;
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;

{-# NEED World #-}
data World;
interface Data.Sequence
{-# NEED Node #-}
data Node a;
interface ! Data.Graph
{-# NEED bcc #-}
bcc{-# 1 #-}::(Graph -> (Data.Tree.Forest [Vertex]));

{-# NEED path #-}
path{-# 3 #-}::(Graph -> (Vertex -> (Vertex -> Prelude.Bool)));

{-# NEED reachable #-}
reachable{-# 2 #-}::(Graph -> (Vertex -> [Vertex]));

{-# NEED scc #-}
scc{-# 1 #-}::(Graph -> (Data.Tree.Forest Vertex));

{-# NEED components #-}
components{-# 0 #-}::(Graph -> (Data.Tree.Forest Vertex));

{-# NEED topSort #-}
topSort{-# 0 #-}::(Graph -> [Vertex]);

{-# NEED dfs #-}
dfs{-# 2 #-}::(Graph -> ([Vertex] -> (Data.Tree.Forest Vertex)));

{-# NEED dff #-}
dff{-# 1 #-}::(Graph -> (Data.Tree.Forest Vertex));

{-# NEED graphFromEdges #-}
graphFromEdges{-# 1 #-}::(Prelude.Ord b) => ([(a,b,[b])] -> (Graph,(Vertex -> (a,b,[b])),(b -> (Prelude.Maybe Vertex))));

{-# NEED graphFromEdges' #-}
graphFromEdges'{-# 1 #-}::(Prelude.Ord b) => ([(a,b,[b])] -> (Graph,(Vertex -> (a,b,[b]))));

{-# NEED indegree #-}
indegree{-# 0 #-}::(Graph -> (Table Prelude.Int));

{-# NEED outdegree #-}
outdegree{-# 0 #-}::(Graph -> (Table Prelude.Int));

{-# NEED transposeG #-}
transposeG{-# 1 #-}::(Graph -> Graph);

{-# NEED buildG #-}
buildG{-# 2 #-}::(Bounds -> ([Edge] -> Graph));

{-# NEED edges #-}
edges{-# 1 #-}::(Graph -> [Edge]);

{-# NEED vertices #-}
vertices{-# 0 #-}::(Graph -> [Vertex]);

{-# NEED Edge #-}
type {-# 5 #-} Edge = (Vertex,Vertex);

{-# NEED Bounds #-}
type {-# 4 #-} Bounds = (Vertex,Vertex);

{-# NEED Graph #-}
type {-# 3 #-} Graph = (Table [Vertex]);

{-# NEED Table #-}
type {-# 2 #-} Table a = (Array.Array Vertex a);
interface Array
{-# NEED Array #-}
data (Ix.Ix a) => Array a b;
interface Ix
{-# NEED Ix #-}
class (Prelude.Ord a) => Ix a;
interface ! Data.Graph
{-# NEED Vertex #-}
type {-# 1 #-} Vertex = Prelude.Int;

{-# NEED stronglyConnCompR #-}
stronglyConnCompR{-# 1 #-}::(Prelude.Ord b) => ([(a,b,[b])] -> [(SCC (a,b,[b]))]);

{-# NEED stronglyConnComp #-}
stronglyConnComp{-# 1 #-}::(Prelude.Ord b) => ([(a,b,[b])] -> [(SCC a)]);

{-# NEED flattenSCC #-}
flattenSCC{-# 1 #-}::((SCC a) -> [a]);

{-# NEED flattenSCCs #-}
flattenSCCs{-# 0 #-}::([(SCC a)] -> [a]);

{-# NEED {SCC AcyclicSCC CyclicSCC} #-}
data SCC a
  = AcyclicSCC a
  | CyclicSCC [a];
interface ! Data.Tree
{-# NEED {Tree Node rootLabel subForest} Forest #-}
data Tree a
  = Node {Data.Tree.rootLabel :: a} {Data.Tree.subForest :: (Data.Tree.Forest a)};
type {-# 1 #-} Forest a = [(Data.Tree.Tree a)];
}
