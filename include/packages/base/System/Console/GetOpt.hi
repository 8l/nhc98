interface System.Console.GetOpt where {

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum NHC.DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Show NHC.DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Show IO.Handle;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Eq NHC.DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Eq IO.Handle;
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;

{-# NEED World #-}
data World;
interface Ratio
{-# NEED Ratio #-}
data Ratio a;
interface NHC.DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface ! System.Console.GetOpt
{-# NEED getOpt' #-}
getOpt'{-# 3 #-}::((ArgOrder a) -> ([(OptDescr a)] -> ([Prelude.String] -> ([a],[Prelude.String],[Prelude.String],[Prelude.String]))));

{-# NEED getOpt #-}
getOpt{-# 3 #-}::((ArgOrder a) -> ([(OptDescr a)] -> ([Prelude.String] -> ([a],[Prelude.String],[Prelude.String]))));

{-# NEED usageInfo #-}
usageInfo{-# 2 #-}::(Prelude.String -> ([(OptDescr a)] -> Prelude.String));

{-# NEED {OptDescr Option} #-}
data OptDescr a
  = Option [Prelude.Char] [Prelude.String] (ArgDescr a) Prelude.String;

{-# NEED {ArgDescr NoArg ReqArg OptArg} #-}
data ArgDescr a
  = NoArg a
  | ReqArg (Prelude.String -> a) Prelude.String
  | OptArg ((Prelude.Maybe Prelude.String) -> a) Prelude.String;

{-# NEED {ArgOrder RequireOrder Permute ReturnInOrder} #-}
data ArgOrder a
  = RequireOrder 
  | Permute 
  | ReturnInOrder (Prelude.String -> a);
}
