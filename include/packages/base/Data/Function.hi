interface Data.Function where {
infixl  0 `on`;
infixr  9 Prelude..;
infixr  0 Prelude.$;

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);
interface Ratio
{-# NEED Ratio #-}
data Ratio a;
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;
interface NHC.DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface NHC.Internal
{-# NEED World #-}
data World;
interface ! Data.Function
{-# NEED on #-}
on{-# 2 #-}::((a -> (a -> b)) -> ((c -> a) -> (c -> (c -> b))));

{-# NEED fix #-}
fix{-# 1 #-}::((a -> a) -> a);
interface ! Prelude
{-# NEED id #-}
id{-# 1 #-}::(a -> a);

{-# NEED (.) #-}
(.){-# 2 #-}::((a -> b) -> ((c -> a) -> (c -> b)));

{-# NEED flip #-}
flip{-# 3 #-}::((a -> (b -> c)) -> (b -> (a -> c)));

{-# NEED ($) #-}
($){-# 2 #-}::((a -> b) -> (a -> b));

{-# NEED const #-}
const{-# 2 #-}::(a -> (b -> a));
}
