interface Data.Tuple where {

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);
interface Ratio
{-# NEED Ratio #-}
data Ratio a;
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;
interface NHC.DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface NHC.Internal
{-# NEED World #-}
data World;
interface ! Data.Tuple
{-# NEED swap #-}
swap{-# 1 #-}::((a,b) -> (b,a));
interface ! Prelude
{-# NEED {(,,) (,,)} #-}
data (,,) a b c
 = (,,) a b c;

{-# NEED {(,,,) (,,,)} #-}
data (,,,) a b c d
 = (,,,) a b c d;

{-# NEED {(,,,,) (,,,,)} #-}
data (,,,,) a b c d e
 = (,,,,) a b c d e;

{-# NEED {(,,,,,) (,,,,,)} #-}
data (,,,,,) a b c d e f
 = (,,,,,) a b c d e f;

{-# NEED {(,,,,,,) (,,,,,,)} #-}
data (,,,,,,) a b c d e f g
 = (,,,,,,) a b c d e f g;

{-# NEED {(,,,,,,,) (,,,,,,,)} #-}
data (,,,,,,,) a b c d e f g h
 = (,,,,,,,) a b c d e f g h;

{-# NEED {(,,,,,,,,) (,,,,,,,,)} #-}
data (,,,,,,,,) a b c d e f g h i
 = (,,,,,,,,) a b c d e f g h i;

{-# NEED {(,,,,,,,,,) (,,,,,,,,,)} #-}
data (,,,,,,,,,) a b c d e f g h i j
 = (,,,,,,,,,) a b c d e f g h i j;

{-# NEED {(,,,,,,,,,,) (,,,,,,,,,,)} #-}
data (,,,,,,,,,,) a b c d e f g h i j k
 = (,,,,,,,,,,) a b c d e f g h i j k;

{-# NEED {(,,,,,,,,,,,) (,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,) a b c d e f g h i j k l
 = (,,,,,,,,,,,) a b c d e f g h i j k l;

{-# NEED {(,,,,,,,,,,,,) (,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,) a b c d e f g h i j k l m
 = (,,,,,,,,,,,,) a b c d e f g h i j k l m;

{-# NEED {(,,,,,,,,,,,,,) (,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,) a b c d e f g h i j k l m n
 = (,,,,,,,,,,,,,) a b c d e f g h i j k l m n;

{-# NEED {(,,,,,,,,,,,,,,) (,,,,,,,,,,,,,,)} #-}
data (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o
 = (,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o;

{-# NEED snd #-}
snd{-# 1 #-}::((a,b) -> b);

{-# NEED fst #-}
fst{-# 1 #-}::((a,b) -> a);

{-# NEED curry #-}
curry{-# 3 #-}::(((a,b) -> c) -> (a -> (b -> c)));

{-# NEED uncurry #-}
uncurry{-# 2 #-}::((a -> (b -> c)) -> ((a,b) -> c));

{-# NEED {(,) (,)} #-}
data (,) a b
 = (,) a b;
}
