interface Data.Foldable where {

{-# NEED #-}
instance (Control.Monad.Fix.MonadFix a) => Control.Arrow.ArrowLoop (Control.Arrow.Kleisli a);

{-# NEED #-}
instance (Prelude.Monad a) => Control.Arrow.ArrowChoice (Control.Arrow.Kleisli a);

{-# NEED #-}
instance Data.Typeable.Typeable1 Ratio.Ratio;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.Internal.IO;

{-# NEED #-}
instance (Ix.Ix a) => Foldable (Array.Array a);

{-# NEED #-}
instance Foldable Prelude.Maybe;

{-# NEED #-}
instance Foldable Prelude.[];

{-# NEED #-}
instance Ix.Ix Prelude.Integer;

{-# NEED #-}
instance Ix.Ix Prelude.Char;

{-# NEED #-}
instance Ix.Ix Prelude.Int;

{-# NEED #-}
instance Ix.Ix Prelude.Ordering;

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b) => Ix.Ix (a,b);

{-# NEED #-}
instance Ix.Ix Prelude.Bool;

{-# NEED #-}
instance (Control.Monad.MonadPlus a) => Control.Applicative.Alternative (Control.Applicative.WrappedMonad a);

{-# NEED #-}
instance (Control.Arrow.ArrowZero a,Control.Arrow.ArrowPlus a) => Control.Applicative.Alternative (Control.Applicative.WrappedArrow a b);

{-# NEED #-}
instance Control.Applicative.Alternative Prelude.Maybe;

{-# NEED #-}
instance Control.Applicative.Alternative Prelude.[];

{-# NEED #-}
instance (Control.Monad.MonadPlus a) => Control.Arrow.ArrowPlus (Control.Arrow.Kleisli a);

{-# NEED #-}
instance Control.Monad.Fix.MonadFix Prelude.Maybe;

{-# NEED #-}
instance Control.Monad.Fix.MonadFix Prelude.[];

{-# NEED #-}
instance Control.Monad.Fix.MonadFix NHC.Internal.IO;

{-# NEED #-}
instance Control.Monad.Fix.MonadFix ( (->) a);

{-# NEED #-}
instance Control.Applicative.Applicative (Prelude.Either a);

{-# NEED #-}
instance (Data.Monoid.Monoid a) => Control.Applicative.Applicative (Control.Applicative.Const a);

{-# NEED #-}
instance (Prelude.Monad a) => Control.Applicative.Applicative (Control.Applicative.WrappedMonad a);

{-# NEED #-}
instance (Control.Arrow.Arrow a) => Control.Applicative.Applicative (Control.Applicative.WrappedArrow a b);

{-# NEED #-}
instance Control.Applicative.Applicative Control.Applicative.ZipList;

{-# NEED #-}
instance (Data.Monoid.Monoid a) => Control.Applicative.Applicative ((,) a);

{-# NEED #-}
instance Control.Applicative.Applicative Prelude.Maybe;

{-# NEED #-}
instance Control.Applicative.Applicative Prelude.[];

{-# NEED #-}
instance Control.Applicative.Applicative NHC.Internal.IO;

{-# NEED #-}
instance Control.Applicative.Applicative ( (->) a);

{-# NEED #-}
instance (Prelude.Monad a) => Control.Category.Category (Control.Arrow.Kleisli a);

{-# NEED #-}
instance Control.Category.Category ( (->) a);

{-# NEED #-}
instance Control.Category.Category (Prelude.Monad a);

{-# NEED #-}
instance Data.Typeable.Typeable IO.Handle;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Ratio.Ratio a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.Internal.IO a);

{-# NEED #-}
instance (Control.Monad.MonadPlus a) => Control.Arrow.ArrowZero (Control.Arrow.Kleisli a);

{-# NEED #-}
instance (Prelude.Monad a) => Control.Arrow.ArrowApply (Control.Arrow.Kleisli a);

{-# NEED #-}
instance Control.Arrow.ArrowApply ( (->) a);

{-# NEED #-}
instance Control.Arrow.ArrowApply (Prelude.Monad a);

{-# NEED #-}
instance (Prelude.Monad a) => Control.Arrow.Arrow (Control.Arrow.Kleisli a);

{-# NEED #-}
instance Control.Arrow.Arrow ( (->) a);

{-# NEED #-}
instance Control.Arrow.Arrow (Prelude.Monad a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum NHC.DErrNo.ErrNo;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Data.Monoid.Monoid Prelude.Ordering;

{-# NEED #-}
instance Data.Monoid.Monoid ();

{-# NEED #-}
instance (Data.Monoid.Monoid a,Data.Monoid.Monoid b) => Data.Monoid.Monoid (a,b);

{-# NEED #-}
instance (Data.Monoid.Monoid a) => Data.Monoid.Monoid (Prelude.Maybe a);

{-# NEED #-}
instance Data.Monoid.Monoid [a];

{-# NEED #-}
instance (Data.Monoid.Monoid a) => Data.Monoid.Monoid (Data.Monoid.Dual a);

{-# NEED #-}
instance Data.Monoid.Monoid (Data.Monoid.Endo a);

{-# NEED #-}
instance Data.Monoid.Monoid Data.Monoid.All;

{-# NEED #-}
instance Data.Monoid.Monoid Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Num a) => Data.Monoid.Monoid (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Num a) => Data.Monoid.Monoid (Data.Monoid.Product a);

{-# NEED #-}
instance (Data.Monoid.Monoid b) => Data.Monoid.Monoid (a -> b);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Bounded a) => Prelude.Bounded (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Bounded Data.Monoid.All;

{-# NEED #-}
instance Prelude.Bounded Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Bounded a) => Prelude.Bounded (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Bounded a) => Prelude.Bounded (Data.Monoid.Product a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Ord b) => Prelude.Ord (Array.Array a b);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Ord Data.Monoid.All;

{-# NEED #-}
instance Prelude.Ord Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.Product a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Eq b) => Prelude.Eq (Array.Array a b);

{-# NEED #-}
instance Prelude.Eq IO.Handle;

{-# NEED #-}
instance Prelude.Eq NHC.DErrNo.ErrNo;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Eq Data.Monoid.All;

{-# NEED #-}
instance Prelude.Eq Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.Product a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Read a,Prelude.Read b) => Prelude.Read (Array.Array a b);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Read Data.Monoid.All;

{-# NEED #-}
instance Prelude.Read Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.Product a);

{-# NEED #-}
instance (Ix.Ix a) => Prelude.Functor (Array.Array a);

{-# NEED #-}
instance Prelude.Functor (Control.Applicative.Const a);

{-# NEED #-}
instance (Prelude.Monad a) => Prelude.Functor (Control.Applicative.WrappedMonad a);

{-# NEED #-}
instance (Control.Arrow.Arrow a) => Prelude.Functor (Control.Applicative.WrappedArrow a b);

{-# NEED #-}
instance Prelude.Functor Control.Applicative.ZipList;

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Show a,Prelude.Show b) => Prelude.Show (Array.Array a b);

{-# NEED #-}
instance Prelude.Show IO.Handle;

{-# NEED #-}
instance Prelude.Show NHC.DErrNo.ErrNo;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Show Data.Monoid.All;

{-# NEED #-}
instance Prelude.Show Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.Product a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);

{-# NEED #-}
instance Control.Monad.MonadPlus Prelude.Maybe;

{-# NEED #-}
instance Control.Monad.MonadPlus Prelude.[];

{-# NEED #-}
instance (Control.Arrow.ArrowApply a) => Prelude.Monad (Control.Arrow.ArrowMonad a);

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;
interface Control.Monad.Fix
{-# NEED MonadFix #-}
class (Prelude.Monad a) => MonadFix a;
interface Control.Arrow
{-# NEED ArrowPlus #-}
class (Control.Arrow.ArrowZero a) => ArrowPlus a;

{-# NEED ArrowZero #-}
class (Control.Arrow.Arrow a) => ArrowZero a;
interface Data.Typeable
{-# NEED Typeable #-}
class Typeable a;
interface Control.Arrow
{-# NEED Kleisli #-}
newtype {-#  #-} Kleisli a b c;
interface Data.Monoid
{-# NEED Endo #-}
newtype {-#  #-} Endo a;
interface Control.Applicative
{-# NEED Const #-}
newtype {-#  #-} Const a b;

{-# NEED WrappedMonad #-}
newtype {-#  #-} WrappedMonad a b;

{-# NEED WrappedArrow #-}
newtype {-#  #-} WrappedArrow a b c;

{-# NEED ZipList #-}
newtype {-#  #-} ZipList a;
interface Array
{-# NEED Array #-}
data (Ix.Ix a) => Array a b;
interface Ix
{-# NEED Ix #-}
class (Prelude.Ord a) => Ix a;
interface Ratio
{-# NEED Ratio #-}
data Ratio a;
interface Data.Monoid
{-# NEED Dual #-}
newtype {-#  #-} Dual a;

{-# NEED All #-}
newtype {-#  #-} All;

{-# NEED Any #-}
newtype {-#  #-} Any;

{-# NEED Sum #-}
newtype {-#  #-} Sum a;

{-# NEED Product #-}
newtype {-#  #-} Product a;
interface Control.Arrow
{-# NEED ArrowMonad #-}
newtype {-#  #-} (Control.Arrow.ArrowApply a) => ArrowMonad a b;

{-# NEED ArrowApply #-}
class (Control.Arrow.Arrow a) => ArrowApply a;

{-# NEED Arrow #-}
class (Control.Category.Category a) => Arrow a;
interface Control.Category
{-# NEED Category #-}
class Category a;
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;
interface NHC.DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface NHC.Internal
{-# NEED World #-}
data World;
interface ! Data.Foldable
{-# NEED find #-}
find{-# 1 #-}::(Foldable b) => ((a -> Prelude.Bool) -> ((b a) -> (Prelude.Maybe a)));

{-# NEED notElem #-}
notElem{-# 1 #-}::(Foldable b,Prelude.Eq a) => (a -> ((b a) -> Prelude.Bool));

{-# NEED elem #-}
elem{-# 0 #-}::(Foldable b,Prelude.Eq a) => (a -> ((b a) -> Prelude.Bool));

{-# NEED minimumBy #-}
minimumBy{-# 1 #-}::(Foldable b) => ((a -> (a -> Prelude.Ordering)) -> ((b a) -> a));

{-# NEED minimum #-}
minimum{-# 0 #-}::(Foldable a,Prelude.Ord b) => ((a b) -> b);

{-# NEED maximumBy #-}
maximumBy{-# 1 #-}::(Foldable b) => ((a -> (a -> Prelude.Ordering)) -> ((b a) -> a));

{-# NEED maximum #-}
maximum{-# 0 #-}::(Foldable a,Prelude.Ord b) => ((a b) -> b);

{-# NEED product #-}
product{-# 0 #-}::(Foldable a,Prelude.Num b) => ((a b) -> b);

{-# NEED sum #-}
sum{-# 0 #-}::(Foldable a,Prelude.Num b) => ((a b) -> b);

{-# NEED all #-}
all{-# 1 #-}::(Foldable b) => ((a -> Prelude.Bool) -> ((b a) -> Prelude.Bool));

{-# NEED any #-}
any{-# 1 #-}::(Foldable b) => ((a -> Prelude.Bool) -> ((b a) -> Prelude.Bool));

{-# NEED or #-}
or{-# 0 #-}::(Foldable a) => ((a Prelude.Bool) -> Prelude.Bool);

{-# NEED and #-}
and{-# 0 #-}::(Foldable a) => ((a Prelude.Bool) -> Prelude.Bool);

{-# NEED concatMap #-}
concatMap{-# 0 #-}::(Foldable c) => ((a -> [b]) -> ((c a) -> [b]));

{-# NEED concat #-}
concat{-# 0 #-}::(Foldable a) => ((a [b]) -> [b]);

{-# NEED toList #-}
toList{-# 0 #-}::(Foldable a) => ((a b) -> [b]);

{-# NEED msum #-}
msum{-# 0 #-}::(Foldable a,Control.Monad.MonadPlus b) => ((a (b c)) -> (b c));
interface Control.Monad
{-# NEED MonadPlus #-}
class (Prelude.Monad a) => MonadPlus a;
interface ! Data.Foldable
{-# NEED asum #-}
asum{-# 0 #-}::(Foldable a,Control.Applicative.Alternative b) => ((a (b c)) -> (b c));
interface Control.Applicative
{-# NEED Alternative #-}
class (Control.Applicative.Applicative a) => Alternative a;
interface ! Data.Foldable
{-# NEED sequence_ #-}
sequence_{-# 0 #-}::(Foldable a,Prelude.Monad b) => ((a (b c)) -> (b ()));

{-# NEED sequenceA_ #-}
sequenceA_{-# 0 #-}::(Foldable a,Control.Applicative.Applicative b) => ((a (b c)) -> (b ()));

{-# NEED forM_ #-}
forM_{-# 0 #-}::(Foldable a,Prelude.Monad c) => ((a b) -> ((b -> (c d)) -> (c ())));

{-# NEED mapM_ #-}
mapM_{-# 1 #-}::(Foldable d,Prelude.Monad b) => ((a -> (b c)) -> ((d a) -> (b ())));

{-# NEED for_ #-}
for_{-# 0 #-}::(Foldable a,Control.Applicative.Applicative c) => ((a b) -> ((b -> (c d)) -> (c ())));

{-# NEED traverse_ #-}
traverse_{-# 1 #-}::(Foldable d,Control.Applicative.Applicative b) => ((a -> (b c)) -> ((d a) -> (b ())));
interface Control.Applicative
{-# NEED Applicative #-}
class (Prelude.Functor a) => Applicative a;
interface ! Data.Foldable
{-# NEED foldlM #-}
foldlM{-# 3 #-}::(Foldable d,Prelude.Monad c) => ((a -> (b -> (c a))) -> (a -> ((d b) -> (c a))));

{-# NEED foldl' #-}
foldl'{-# 3 #-}::(Foldable c) => ((a -> (b -> a)) -> (a -> ((c b) -> a)));

{-# NEED foldrM #-}
foldrM{-# 3 #-}::(Foldable d,Prelude.Monad c) => ((a -> (b -> (c b))) -> (b -> ((d a) -> (c b))));

{-# NEED foldr' #-}
foldr'{-# 3 #-}::(Foldable c) => ((a -> (b -> b)) -> (b -> ((c a) -> b)));

{-# NEED {Foldable fold foldMap foldr foldl foldr1 foldl1} #-}
class Foldable a where {
  fold{-# 1 #-}::(Data.Monoid.Monoid b) => ((a b) -> b);
  foldMap{-# 2 #-}::(Data.Monoid.Monoid c) => ((b -> c) -> ((a b) -> c));
  foldr{-# 3 #-}::((b -> (c -> c)) -> (c -> ((a b) -> c)));
  foldl{-# 3 #-}::((b -> (c -> b)) -> (b -> ((a c) -> b)));
  foldr1{-# 2 #-}::((b -> (b -> b)) -> ((a b) -> b));
  foldl1{-# 2 #-}::((b -> (b -> b)) -> ((a b) -> b));
};
interface Data.Monoid
{-# NEED Monoid #-}
class Monoid a;
}
