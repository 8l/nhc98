interface Distribution.Simple.Compiler where {

{-# NEED #-}
instance Control.Monad.MonadPlus Text.ParserCombinators.ReadP.P;

{-# NEED #-}
instance Control.Monad.MonadPlus (Text.ParserCombinators.ReadP.ReadPN a);

{-# NEED #-}
instance Data.Typeable.Typeable2 Array.Array;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.Internal.IO;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable1 (Array.Array a);

{-# NEED #-}
instance Data.Typeable.Typeable1 Ratio.Ratio;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Monad Text.ParserCombinators.ReadP.P;

{-# NEED #-}
instance Prelude.Monad (Distribution.Compat.ReadP.Parser a b);

{-# NEED #-}
instance Prelude.Monad (Text.ParserCombinators.ReadP.ReadPN a);

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Functor (Distribution.Compat.ReadP.Parser a b);

{-# NEED #-}
instance Prelude.Functor (Text.ParserCombinators.ReadP.ReadPN a);

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance (Ix.Ix a) => Prelude.Functor (Array.Array a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance Data.Typeable.Typeable ();

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Float;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Double;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Char;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Int;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Ordering;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Integer;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.Internal.IO a);

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (Array.Array a b);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Ratio.Ratio a);

{-# NEED #-}
instance Data.Typeable.Typeable Data.Version.Version;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable [a];

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Bool;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Prelude.Maybe a);

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (a -> b);

{-# NEED #-}
instance Prelude.Bounded OptimisationLevel;

{-# NEED #-}
instance Prelude.Bounded Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CInt;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Num NHC.FFI.CInt;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Real NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Enum OptimisationLevel;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Ord Distribution.Compiler.CompilerFlavor;

{-# NEED #-}
instance Prelude.Ord Distribution.Compiler.CompilerId;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Ord b) => Prelude.Ord (Array.Array a b);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Ord Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Ord Data.Version.Version;

{-# NEED #-}
instance Ix.Ix Prelude.Char;

{-# NEED #-}
instance Ix.Ix Prelude.Int;

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m,Ix.Ix n,Ix.Ix o) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m,Ix.Ix n) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j) => Ix.Ix (a,b,c,d,e,f,g,h,i,j);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i) => Ix.Ix (a,b,c,d,e,f,g,h,i);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h) => Ix.Ix (a,b,c,d,e,f,g,h);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g) => Ix.Ix (a,b,c,d,e,f,g);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f) => Ix.Ix (a,b,c,d,e,f);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e) => Ix.Ix (a,b,c,d,e);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d) => Ix.Ix (a,b,c,d);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c) => Ix.Ix (a,b,c);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b) => Ix.Ix (a,b);

{-# NEED #-}
instance Ix.Ix Prelude.Ordering;

{-# NEED #-}
instance Ix.Ix Prelude.Integer;

{-# NEED #-}
instance Ix.Ix Data.Char.GeneralCategory;

{-# NEED #-}
instance Ix.Ix Prelude.Bool;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CInt;

{-# NEED #-}
instance Distribution.Text.Text Distribution.Compiler.CompilerFlavor;

{-# NEED #-}
instance Distribution.Text.Text Distribution.Compiler.CompilerId;

{-# NEED #-}
instance Distribution.Text.Text Data.Version.Version;

{-# NEED #-}
instance Distribution.Text.Text Distribution.Version.VersionRange;

{-# NEED #-}
instance Distribution.Text.Text Distribution.Version.VersionWildcard;

{-# NEED #-}
instance Distribution.Text.Text Language.Haskell.Extension.Extension;

{-# NEED #-}
instance Distribution.Text.Text Prelude.Bool;

{-# NEED #-}
instance Prelude.Read OptimisationLevel;

{-# NEED #-}
instance Prelude.Read PackageDB;

{-# NEED #-}
instance Prelude.Read Compiler;

{-# NEED #-}
instance Prelude.Read Distribution.Compiler.CompilerFlavor;

{-# NEED #-}
instance Prelude.Read Distribution.Compiler.CompilerId;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Read a,Prelude.Read b) => Prelude.Read (Array.Array a b);

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Read Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Read Data.Version.Version;

{-# NEED #-}
instance Prelude.Read Distribution.Version.VersionRange;

{-# NEED #-}
instance Prelude.Read Language.Haskell.Extension.Extension;

{-# NEED #-}
instance Prelude.Eq OptimisationLevel;

{-# NEED #-}
instance Prelude.Eq PackageDB;

{-# NEED #-}
instance Prelude.Eq Distribution.Compiler.CompilerFlavor;

{-# NEED #-}
instance Prelude.Eq Distribution.Compiler.CompilerId;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Eq b) => Prelude.Eq (Array.Array a b);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Eq Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Eq Data.Version.Version;

{-# NEED #-}
instance Prelude.Eq Distribution.Version.VersionRange;

{-# NEED #-}
instance Prelude.Eq Language.Haskell.Extension.Extension;

{-# NEED #-}
instance Prelude.Show OptimisationLevel;

{-# NEED #-}
instance Prelude.Show PackageDB;

{-# NEED #-}
instance Prelude.Show Compiler;

{-# NEED #-}
instance Prelude.Show Distribution.Compiler.CompilerFlavor;

{-# NEED #-}
instance Prelude.Show Distribution.Compiler.CompilerId;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);

{-# NEED #-}
instance Prelude.Show Text.PrettyPrint.HughesPJ.Doc;

{-# NEED #-}
instance (Ix.Ix a,Prelude.Show a,Prelude.Show b) => Prelude.Show (Array.Array a b);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Show Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Show Data.Version.Version;

{-# NEED #-}
instance Prelude.Show Distribution.Version.VersionRange;

{-# NEED #-}
instance Prelude.Show Language.Haskell.Extension.Extension;
interface Text.ParserCombinators.ReadP
{-# NEED P #-}
data P a;

{-# NEED ReadPN #-}
newtype {-#  #-} ReadPN a b;
interface Data.Typeable
{-# NEED Typeable #-}
class Typeable a;
interface Distribution.Version
{-# NEED VersionWildcard #-}
newtype {-#  #-} VersionWildcard;
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;

{-# NEED World #-}
data World;
interface Text.PrettyPrint.HughesPJ
{-# NEED Doc #-}
data Doc;
interface Array
{-# NEED Array #-}
data (Ix.Ix a) => Array a b;
interface Ix
{-# NEED Ix #-}
class (Prelude.Ord a) => Ix a;
interface Ratio
{-# NEED Ratio #-}
data (Prelude.Integral a) => Ratio a;
interface Data.Char
{-# NEED GeneralCategory #-}
data GeneralCategory;
interface NHC.FFI
{-# NEED CInt #-}
newtype {-#  #-} CInt;
interface Distribution.Version
{-# NEED VersionRange #-}
data VersionRange;
interface ! Distribution.Simple.Compiler
{-# NEED extensionsToFlags #-}
extensionsToFlags{-# 2 #-}::(Compiler -> ([Language.Haskell.Extension.Extension] -> [Flag]));

{-# NEED Flag #-}
type {-# 2 #-} Flag = Prelude.String;

{-# NEED unsupportedExtensions #-}
unsupportedExtensions{-# 2 #-}::(Compiler -> ([Language.Haskell.Extension.Extension] -> [Language.Haskell.Extension.Extension]));

{-# NEED flagToOptimisationLevel #-}
flagToOptimisationLevel{-# 1 #-}::((Prelude.Maybe Prelude.String) -> OptimisationLevel);

{-# NEED {OptimisationLevel NoOptimisation NormalOptimisation MaximumOptimisation} #-}
data OptimisationLevel
  = NoOptimisation 
  | NormalOptimisation 
  | MaximumOptimisation ;

{-# NEED {PackageDB GlobalPackageDB UserPackageDB SpecificPackageDB} #-}
data PackageDB
  = GlobalPackageDB 
  | UserPackageDB 
  | SpecificPackageDB Prelude.FilePath;

{-# NEED compilerVersion #-}
compilerVersion{-# 0 #-}::(Compiler -> Data.Version.Version);

{-# NEED compilerFlavor #-}
compilerFlavor{-# 0 #-}::(Compiler -> Distribution.Compiler.CompilerFlavor);

{-# NEED showCompilerId #-}
showCompilerId{-# 0 #-}::(Compiler -> Prelude.String);

{-# NEED {Compiler Compiler compilerId compilerExtensions} #-}
data Compiler
  = Compiler {compilerId :: Distribution.Compiler.CompilerId} {compilerExtensions :: [(Language.Haskell.Extension.Extension,Prelude.String)]};
interface Language.Haskell.Extension
{-# NEED Extension #-}
data Extension;
interface ! Distribution.Compiler
{-# NEED parseCompilerFlavorCompat #-}
parseCompilerFlavorCompat{-# 0 #-}::(Distribution.Compat.ReadP.ReadP a Distribution.Compiler.CompilerFlavor);
interface Distribution.Compat.ReadP
{-# NEED ReadP #-}
type {-# 1 #-} ReadP a b = (Distribution.Compat.ReadP.Parser a Prelude.Char b);

{-# NEED Parser #-}
newtype {-#  #-} Parser a b c;
interface ! Distribution.Compiler
{-# NEED buildCompilerFlavor #-}
buildCompilerFlavor{-# 0 #-}::Distribution.Compiler.CompilerFlavor;

{-# NEED defaultCompilerFlavor #-}
defaultCompilerFlavor{-# 0 #-}::(Prelude.Maybe Distribution.Compiler.CompilerFlavor);

{-# NEED {CompilerId CompilerId} #-}
data CompilerId
  = CompilerId Distribution.Compiler.CompilerFlavor Data.Version.Version;
interface Data.Version
{-# NEED Version #-}
data Version;
interface ! Distribution.Compiler
{-# NEED {CompilerFlavor GHC NHC YHC Hugs HBC Helium JHC OtherCompiler} #-}
data CompilerFlavor
  = GHC 
  | NHC 
  | YHC 
  | Hugs 
  | HBC 
  | Helium 
  | JHC 
  | OtherCompiler Prelude.String;
}
