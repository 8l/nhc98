interface Data.ByteString where {

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CInt;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CWchar;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CSize;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CUInt;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CULLong;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CLLong;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CULong;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CLong;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CUShort;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CShort;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CUChar;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CSChar;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.CChar;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int8;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word8;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int16;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word16;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int32;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word32;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Int64;

{-# NEED #-}
instance Data.Bits.Bits NHC.FFI.Word64;

{-# NEED #-}
instance Data.Typeable.Typeable2 Array.Array;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.FFI.FunPtr;

{-# NEED #-}
instance Data.Typeable.Typeable1 Ratio.Ratio;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.FFI.StablePtr;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable1 (Array.Array a);

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.FFI.ForeignPtr;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.FFI.Ptr;

{-# NEED #-}
instance Data.Typeable.Typeable1 NHC.Internal.IO;

{-# NEED #-}
instance Control.Exception.Base.Exception Prelude.IOError;

{-# NEED #-}
instance Control.Exception.Base.Exception System.ExitCode;

{-# NEED #-}
instance Control.Exception.Base.Exception Control.Exception.Base.SomeException;

{-# NEED #-}
instance Data.Monoid.Monoid Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance (Data.Monoid.Monoid a) => Data.Monoid.Monoid (Prelude.Maybe a);

{-# NEED #-}
instance Data.Monoid.Monoid [a];

{-# NEED #-}
instance Data.Monoid.Monoid (Data.Monoid.First a);

{-# NEED #-}
instance Data.Monoid.Monoid (Data.Monoid.Last a);

{-# NEED #-}
instance (Data.Monoid.Monoid a) => Data.Monoid.Monoid (Data.Monoid.Dual a);

{-# NEED #-}
instance Data.Monoid.Monoid Data.Monoid.All;

{-# NEED #-}
instance Data.Monoid.Monoid Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Num a) => Data.Monoid.Monoid (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Num a) => Data.Monoid.Monoid (Data.Monoid.Product a);

{-# NEED #-}
instance (Data.Monoid.Monoid a,Data.Monoid.Monoid b,Data.Monoid.Monoid c,Data.Monoid.Monoid d,Data.Monoid.Monoid e) => Data.Monoid.Monoid (a,b,c,d,e);

{-# NEED #-}
instance (Data.Monoid.Monoid a,Data.Monoid.Monoid b,Data.Monoid.Monoid c,Data.Monoid.Monoid d) => Data.Monoid.Monoid (a,b,c,d);

{-# NEED #-}
instance (Data.Monoid.Monoid a,Data.Monoid.Monoid b,Data.Monoid.Monoid c) => Data.Monoid.Monoid (a,b,c);

{-# NEED #-}
instance Data.Monoid.Monoid Prelude.Ordering;

{-# NEED #-}
instance (Data.Monoid.Monoid a,Data.Monoid.Monoid b) => Data.Monoid.Monoid (a,b);

{-# NEED #-}
instance Data.Monoid.Monoid ();

{-# NEED #-}
instance (Data.Monoid.Monoid b) => Data.Monoid.Monoid (a -> b);

{-# NEED #-}
instance Prelude.Floating NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Floating NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Floating NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.RealFloat NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.RealFloat NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.RealFloat NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Fractional NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Fractional NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Fractional NHC.FFI.CFloat;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Fractional (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.RealFrac NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.RealFrac NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.RealFrac NHC.FFI.CFloat;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.RealFrac (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Num NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CClock;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CTime;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Num NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Num NHC.FFI.Word64;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Num (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Real NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CClock;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CTime;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Real NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Real NHC.FFI.Word64;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Real (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Integral NHC.FFI.Word64;

{-# NEED #-}
instance (Prelude.Bounded a) => Prelude.Bounded (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Bounded Data.Monoid.All;

{-# NEED #-}
instance Prelude.Bounded Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Bounded a) => Prelude.Bounded (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Bounded a) => Prelude.Bounded (Data.Monoid.Product a);

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Bounded IO.SeekMode;

{-# NEED #-}
instance Prelude.Bounded Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Bounded NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Bounded IO.IOMode;

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m,Ix.Ix n) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n);

{-# NEED #-}
instance Ix.Ix IO.SeekMode;

{-# NEED #-}
instance Ix.Ix Prelude.Bool;

{-# NEED #-}
instance Ix.Ix Prelude.Char;

{-# NEED #-}
instance Ix.Ix Data.Char.GeneralCategory;

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m,Ix.Ix n,Ix.Ix o) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l,Ix.Ix m) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l,m);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k,Ix.Ix l) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k,l);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j,Ix.Ix k) => Ix.Ix (a,b,c,d,e,f,g,h,i,j,k);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i,Ix.Ix j) => Ix.Ix (a,b,c,d,e,f,g,h,i,j);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h,Ix.Ix i) => Ix.Ix (a,b,c,d,e,f,g,h,i);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g,Ix.Ix h) => Ix.Ix (a,b,c,d,e,f,g,h);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f,Ix.Ix g) => Ix.Ix (a,b,c,d,e,f,g);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e,Ix.Ix f) => Ix.Ix (a,b,c,d,e,f);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d,Ix.Ix e) => Ix.Ix (a,b,c,d,e);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c,Ix.Ix d) => Ix.Ix (a,b,c,d);

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b,Ix.Ix c) => Ix.Ix (a,b,c);

{-# NEED #-}
instance Ix.Ix Prelude.Ordering;

{-# NEED #-}
instance (Ix.Ix a,Ix.Ix b) => Ix.Ix (a,b);

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int8;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word8;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int16;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word16;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int32;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word32;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Int64;

{-# NEED #-}
instance Ix.Ix NHC.FFI.Word64;

{-# NEED #-}
instance Ix.Ix Prelude.Integer;

{-# NEED #-}
instance Ix.Ix Prelude.Int;

{-# NEED #-}
instance Ix.Ix IO.IOMode;

{-# NEED #-}
instance Prelude.Read System.ExitCode;

{-# NEED #-}
instance Prelude.Read Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.First a);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.Last a);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Read Data.Monoid.All;

{-# NEED #-}
instance Prelude.Read Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Read a) => Prelude.Read (Data.Monoid.Product a);

{-# NEED #-}
instance Prelude.Read IO.BufferMode;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CClock;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CTime;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Read NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Read IO.SeekMode;

{-# NEED #-}
instance Prelude.Read Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Read NHC.FFI.Word64;

{-# NEED #-}
instance (Prelude.Read a,Prelude.Integral a) => Prelude.Read (Ratio.Ratio a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Read a,Prelude.Read b) => Prelude.Read (Array.Array a b);

{-# NEED #-}
instance Prelude.Read IO.IOMode;

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (Prelude.Either a b);

{-# NEED #-}
instance Data.Typeable.Typeable Control.Exception.Base.SomeException;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Prelude.Maybe a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable [a];

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Float;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Double;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Bool;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Char;

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Ordering;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int8;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word8;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int16;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word16;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int32;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word32;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Int64;

{-# NEED #-}
instance Data.Typeable.Typeable NHC.FFI.Word64;

{-# NEED #-}
instance Data.Typeable.Typeable Data.Typeable.TypeRep;

{-# NEED #-}
instance Data.Typeable.Typeable Data.Typeable.TyCon;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (Ratio.Ratio a);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.FFI.StablePtr a);

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (Array.Array a b);

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.FFI.ForeignPtr a);

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Integer;

{-# NEED #-}
instance Data.Typeable.Typeable ();

{-# NEED #-}
instance Data.Typeable.Typeable Prelude.Int;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.FFI.Ptr a);

{-# NEED #-}
instance Data.Typeable.Typeable IO.Handle;

{-# NEED #-}
instance (Data.Typeable.Typeable a) => Data.Typeable.Typeable (NHC.Internal.IO a);

{-# NEED #-}
instance (Data.Typeable.Typeable a,Data.Typeable.Typeable b) => Data.Typeable.Typeable (a -> b);

{-# NEED #-}
instance (Ix.Ix a) => Prelude.Functor (Array.Array a);

{-# NEED #-}
instance Prelude.Functor NHC.Internal.IO;

{-# NEED #-}
instance Prelude.Monad NHC.Internal.IO;

{-# NEED #-}
instance NHC.FFI.Storable Prelude.Float;

{-# NEED #-}
instance NHC.FFI.Storable Prelude.Double;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CLDouble;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CDouble;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CFloat;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CClock;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CTime;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CInt;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CPtrdiff;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CWchar;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CSigAtomic;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CSize;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CUInt;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CULLong;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CLLong;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CULong;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CLong;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CUShort;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CShort;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CUChar;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CSChar;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.CChar;

{-# NEED #-}
instance NHC.FFI.Storable Prelude.Bool;

{-# NEED #-}
instance NHC.FFI.Storable Prelude.Char;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int8;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word8;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int16;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word16;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int32;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word32;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Int64;

{-# NEED #-}
instance NHC.FFI.Storable NHC.FFI.Word64;

{-# NEED #-}
instance NHC.FFI.Storable (NHC.FFI.FunPtr a);

{-# NEED #-}
instance NHC.FFI.Storable (NHC.FFI.StablePtr a);

{-# NEED #-}
instance NHC.FFI.Storable Prelude.Int;

{-# NEED #-}
instance NHC.FFI.Storable (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Eq System.ExitCode;

{-# NEED #-}
instance Prelude.Eq Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.First a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.Last a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Eq Data.Monoid.All;

{-# NEED #-}
instance Prelude.Eq Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Eq a) => Prelude.Eq (Data.Monoid.Product a);

{-# NEED #-}
instance Prelude.Eq IO.HandlePosn;

{-# NEED #-}
instance Prelude.Eq Data.HashTable.Inserts;

{-# NEED #-}
instance Prelude.Eq Data.HashTable.HashData;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.Key;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.KeyPr;

{-# NEED #-}
instance Prelude.Eq DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Eq NHC.DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Eq IO.BufferMode;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CClock;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CTime;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Eq IO.SeekMode;

{-# NEED #-}
instance Prelude.Eq Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Eq NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.TypeRep;

{-# NEED #-}
instance Prelude.Eq Data.Typeable.TyCon;

{-# NEED #-}
instance Prelude.Eq (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Eq (Ratio.Ratio a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Eq b) => Prelude.Eq (Array.Array a b);

{-# NEED #-}
instance Prelude.Eq (NHC.FFI.ForeignPtr a);

{-# NEED #-}
instance Prelude.Eq (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Eq IO.Handle;

{-# NEED #-}
instance Prelude.Eq IO.IOMode;

{-# NEED #-}
instance Prelude.Ord System.ExitCode;

{-# NEED #-}
instance Prelude.Ord Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.First a);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.Last a);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Ord Data.Monoid.All;

{-# NEED #-}
instance Prelude.Ord Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Ord a) => Prelude.Ord (Data.Monoid.Product a);

{-# NEED #-}
instance Prelude.Ord IO.BufferMode;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CClock;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CTime;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Ord IO.SeekMode;

{-# NEED #-}
instance Prelude.Ord Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Ord NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Ord (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Ord (Ratio.Ratio a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Ord b) => Prelude.Ord (Array.Array a b);

{-# NEED #-}
instance Prelude.Ord (NHC.FFI.ForeignPtr a);

{-# NEED #-}
instance Prelude.Ord (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Ord IO.IOMode;

{-# NEED #-}
instance Prelude.Enum DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Enum NHC.DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CClock;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CTime;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Enum IO.SeekMode;

{-# NEED #-}
instance Prelude.Enum Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Enum NHC.FFI.Word64;

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Enum (Ratio.Ratio a);

{-# NEED #-}
instance Prelude.Enum (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Enum IO.IOMode;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.RecUpdError;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.RecSelError;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.RecConError;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.ErrorCall;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.BlockedIndefinitelyOnSTM;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.BlockedIndefinitelyOnMVar;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.Deadlock;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.NoMethodError;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.PatternMatchFail;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.AssertionFailed;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.AsyncException;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.ArrayException;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.ArithException;

{-# NEED #-}
instance Prelude.Show System.ExitCode;

{-# NEED #-}
instance Prelude.Show Control.Exception.Base.SomeException;

{-# NEED #-}
instance Prelude.Show Data.ByteString.Internal.ByteString;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.First a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.Last a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.Dual a);

{-# NEED #-}
instance Prelude.Show Data.Monoid.All;

{-# NEED #-}
instance Prelude.Show Data.Monoid.Any;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.Sum a);

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (Data.Monoid.Product a);

{-# NEED #-}
instance Prelude.Show IO.HandlePosn;

{-# NEED #-}
instance Prelude.Show Data.HashTable.HashData;

{-# NEED #-}
instance Prelude.Show DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Show NHC.DErrNo.ErrNo;

{-# NEED #-}
instance Prelude.Show IO.BufferMode;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CLDouble;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CDouble;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CFloat;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CClock;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CTime;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CInt;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CPtrdiff;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CWchar;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CSigAtomic;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CSize;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CUInt;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CULLong;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CLLong;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CULong;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CLong;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CUShort;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CShort;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CUChar;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CSChar;

{-# NEED #-}
instance Prelude.Show NHC.FFI.CChar;

{-# NEED #-}
instance Prelude.Show IO.SeekMode;

{-# NEED #-}
instance Prelude.Show Data.Char.GeneralCategory;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int8;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word8;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int16;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word16;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int32;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word32;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Int64;

{-# NEED #-}
instance Prelude.Show NHC.FFI.Word64;

{-# NEED #-}
instance Prelude.Show Data.Typeable.TypeRep;

{-# NEED #-}
instance Prelude.Show Data.Typeable.TyCon;

{-# NEED #-}
instance Prelude.Show (NHC.FFI.FunPtr a);

{-# NEED #-}
instance (Prelude.Integral a) => Prelude.Show (Ratio.Ratio a);

{-# NEED #-}
instance (Ix.Ix a,Prelude.Show a,Prelude.Show b) => Prelude.Show (Array.Array a b);

{-# NEED #-}
instance Prelude.Show (NHC.FFI.ForeignPtr a);

{-# NEED #-}
instance Prelude.Show (NHC.FFI.Ptr a);

{-# NEED #-}
instance Prelude.Show IO.Handle;

{-# NEED #-}
instance (Prelude.Show a) => Prelude.Show (NHC.Internal.IO a);

{-# NEED #-}
instance Prelude.Show IO.IOMode;
interface Data.Monoid
{-# NEED Monoid #-}
class Monoid a;
interface Data.Typeable
{-# NEED Typeable #-}
class Typeable a;
interface NHC.FFI
{-# NEED StablePtr #-}
data StablePtr a;
interface Data.HashTable
{-# NEED Inserts #-}
data Inserts;
interface Data.Typeable
{-# NEED Key #-}
newtype {-#  #-} Key;

{-# NEED KeyPr #-}
data KeyPr;
interface Control.Exception.Base
{-# NEED RecUpdError #-}
data RecUpdError;

{-# NEED RecSelError #-}
data RecSelError;

{-# NEED RecConError #-}
data RecConError;

{-# NEED ErrorCall #-}
data ErrorCall;

{-# NEED BlockedIndefinitelyOnSTM #-}
data BlockedIndefinitelyOnSTM;

{-# NEED BlockedIndefinitelyOnMVar #-}
data BlockedIndefinitelyOnMVar;

{-# NEED Deadlock #-}
data Deadlock;

{-# NEED NoMethodError #-}
data NoMethodError;

{-# NEED PatternMatchFail #-}
data PatternMatchFail;

{-# NEED AssertionFailed #-}
data AssertionFailed;

{-# NEED AsyncException #-}
data AsyncException;

{-# NEED ArrayException #-}
data ArrayException;

{-# NEED ArithException #-}
data ArithException;
interface System
{-# NEED ExitCode #-}
data ExitCode;
interface Control.Exception.Base
{-# NEED SomeException #-}
data SomeException;
interface Data.Monoid
{-# NEED First #-}
newtype {-#  #-} First a;

{-# NEED Last #-}
newtype {-#  #-} Last a;

{-# NEED Dual #-}
newtype {-#  #-} Dual a;

{-# NEED All #-}
newtype {-#  #-} All;

{-# NEED Any #-}
newtype {-#  #-} Any;

{-# NEED Sum #-}
newtype {-#  #-} Sum a;

{-# NEED Product #-}
newtype {-#  #-} Product a;
interface IO
{-# NEED HandlePosn #-}
data HandlePosn;
interface Data.HashTable
{-# NEED HashData #-}
data HashData;
interface DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface IO
{-# NEED BufferMode #-}
data BufferMode;
interface NHC.FFI
{-# NEED CLDouble #-}
newtype {-#  #-} CLDouble;

{-# NEED CDouble #-}
newtype {-#  #-} CDouble;

{-# NEED CFloat #-}
newtype {-#  #-} CFloat;

{-# NEED CClock #-}
newtype {-#  #-} CClock;

{-# NEED CTime #-}
newtype {-#  #-} CTime;

{-# NEED CPtrdiff #-}
newtype {-#  #-} CPtrdiff;

{-# NEED CWchar #-}
newtype {-#  #-} CWchar;

{-# NEED CSigAtomic #-}
newtype {-#  #-} CSigAtomic;

{-# NEED CSize #-}
newtype {-#  #-} CSize;

{-# NEED CInt #-}
newtype {-#  #-} CInt;

{-# NEED CUInt #-}
newtype {-#  #-} CUInt;

{-# NEED CULLong #-}
newtype {-#  #-} CULLong;

{-# NEED CLLong #-}
newtype {-#  #-} CLLong;

{-# NEED CULong #-}
newtype {-#  #-} CULong;

{-# NEED CLong #-}
newtype {-#  #-} CLong;

{-# NEED CUShort #-}
newtype {-#  #-} CUShort;

{-# NEED CShort #-}
newtype {-#  #-} CShort;

{-# NEED CUChar #-}
newtype {-#  #-} CUChar;

{-# NEED CSChar #-}
newtype {-#  #-} CSChar;
interface IO
{-# NEED SeekMode #-}
data SeekMode;
interface Data.Char
{-# NEED GeneralCategory #-}
data GeneralCategory;
interface NHC.FFI
{-# NEED Int8 #-}
data Int8;

{-# NEED Int16 #-}
data Int16;

{-# NEED Word16 #-}
data Word16;

{-# NEED Int32 #-}
data Int32;

{-# NEED Word32 #-}
data Word32;

{-# NEED Int64 #-}
data Int64;

{-# NEED Word64 #-}
data Word64;
interface Data.Typeable
{-# NEED TypeRep #-}
data TypeRep;

{-# NEED TyCon #-}
data TyCon;
interface NHC.FFI
{-# NEED FunPtr #-}
data FunPtr a;
interface Ratio
{-# NEED Ratio #-}
data Ratio a;
interface Array
{-# NEED Array #-}
data (Ix.Ix a) => Array a b;
interface Ix
{-# NEED Ix #-}
class (Prelude.Ord a) => Ix a;
interface NHC.FFI
{-# NEED ForeignPtr #-}
data ForeignPtr a;
interface IO
{-# NEED IOMode #-}
data IOMode;
interface ! Data.ByteString
{-# NEED appendFile #-}
appendFile{-# 2 #-}::(Prelude.FilePath -> (Data.ByteString.Internal.ByteString -> (NHC.Internal.IO ())));

{-# NEED writeFile #-}
writeFile{-# 2 #-}::(Prelude.FilePath -> (Data.ByteString.Internal.ByteString -> (NHC.Internal.IO ())));

{-# NEED readFile #-}
readFile{-# 1 #-}::(Prelude.FilePath -> (NHC.Internal.IO Data.ByteString.Internal.ByteString));

{-# NEED interact #-}
interact{-# 1 #-}::((Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString) -> (NHC.Internal.IO ()));

{-# NEED getContents #-}
getContents{-# 0 #-}::(NHC.Internal.IO Data.ByteString.Internal.ByteString);

{-# NEED hGetContents #-}
hGetContents{-# 1 #-}::(IO.Handle -> (NHC.Internal.IO Data.ByteString.Internal.ByteString));

{-# NEED hGetNonBlocking #-}
hGetNonBlocking{-# 0 #-}::(IO.Handle -> (Prelude.Int -> (NHC.Internal.IO Data.ByteString.Internal.ByteString)));

{-# NEED hGet #-}
hGet{-# 2 #-}::(IO.Handle -> (Prelude.Int -> (NHC.Internal.IO Data.ByteString.Internal.ByteString)));

{-# NEED putStrLn #-}
putStrLn{-# 0 #-}::(Data.ByteString.Internal.ByteString -> (NHC.Internal.IO ()));

{-# NEED putStr #-}
putStr{-# 0 #-}::(Data.ByteString.Internal.ByteString -> (NHC.Internal.IO ()));

{-# NEED hPutStrLn #-}
hPutStrLn{-# 2 #-}::(IO.Handle -> (Data.ByteString.Internal.ByteString -> (NHC.Internal.IO ())));

{-# NEED hPutStr #-}
hPutStr{-# 0 #-}::(IO.Handle -> (Data.ByteString.Internal.ByteString -> (NHC.Internal.IO ())));

{-# NEED hPut #-}
hPut{-# 2 #-}::(IO.Handle -> (Data.ByteString.Internal.ByteString -> (NHC.Internal.IO ())));

{-# NEED hGetLine #-}
hGetLine{-# 1 #-}::(IO.Handle -> (NHC.Internal.IO Data.ByteString.Internal.ByteString));

{-# NEED getLine #-}
getLine{-# 0 #-}::(NHC.Internal.IO Data.ByteString.Internal.ByteString);

{-# NEED copy #-}
copy{-# 1 #-}::(Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString);

{-# NEED packCStringLen #-}
packCStringLen{-# 1 #-}::(Foreign.C.String.CStringLen -> (NHC.Internal.IO Data.ByteString.Internal.ByteString));

{-# NEED packCString #-}
packCString{-# 1 #-}::(Foreign.C.String.CString -> (NHC.Internal.IO Data.ByteString.Internal.ByteString));

{-# NEED useAsCStringLen #-}
useAsCStringLen{-# 2 #-}::(Data.ByteString.Internal.ByteString -> ((Foreign.C.String.CStringLen -> (NHC.Internal.IO a)) -> (NHC.Internal.IO a)));
interface Foreign.C.String
{-# NEED CStringLen #-}
type {-# 2 #-} CStringLen = ((NHC.FFI.Ptr NHC.FFI.CChar),Prelude.Int);
interface ! Data.ByteString
{-# NEED useAsCString #-}
useAsCString{-# 2 #-}::(Data.ByteString.Internal.ByteString -> ((Foreign.C.String.CString -> (NHC.Internal.IO a)) -> (NHC.Internal.IO a)));
interface NHC.Internal
{-# NEED IO #-}
newtype {-#  #-} IO a;
interface NHC.DErrNo
{-# NEED ErrNo #-}
data ErrNo;
interface IO
{-# NEED Handle #-}
newtype {-#  #-} Handle;
interface NHC.Internal
{-# NEED World #-}
data World;
interface Foreign.C.String
{-# NEED CString #-}
type {-# 1 #-} CString = (NHC.FFI.Ptr NHC.FFI.CChar);
interface NHC.FFI
{-# NEED CChar #-}
newtype {-#  #-} CChar;

{-# NEED Ptr #-}
data Ptr a;
interface ! Data.ByteString
{-# NEED sort #-}
sort{-# 1 #-}::(Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString);

{-# NEED tails #-}
tails{-# 1 #-}::(Data.ByteString.Internal.ByteString -> [Data.ByteString.Internal.ByteString]);

{-# NEED inits #-}
inits{-# 1 #-}::(Data.ByteString.Internal.ByteString -> [Data.ByteString.Internal.ByteString]);

{-# NEED unzip #-}
unzip{-# 1 #-}::([(NHC.FFI.Word8,NHC.FFI.Word8)] -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString));

{-# NEED zipWith #-}
zipWith{-# 3 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> a)) -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> [a])));

{-# NEED zip #-}
zip{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> [(NHC.FFI.Word8,NHC.FFI.Word8)]));

{-# NEED findSubstrings #-}
findSubstrings{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> [Prelude.Int]));

{-# NEED findSubstring #-}
findSubstring{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> (Prelude.Maybe Prelude.Int)));

{-# NEED breakSubstring #-}
breakSubstring{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED isInfixOf #-}
isInfixOf{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> Prelude.Bool));

{-# NEED isSuffixOf #-}
isSuffixOf{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> Prelude.Bool));

{-# NEED isPrefixOf #-}
isPrefixOf{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> Prelude.Bool));

{-# NEED partition #-}
partition{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED find #-}
find{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> (Prelude.Maybe NHC.FFI.Word8)));

{-# NEED filter #-}
filter{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED notElem #-}
notElem{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> Prelude.Bool));

{-# NEED elem #-}
elem{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> Prelude.Bool));

{-# NEED findIndices #-}
findIndices{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> [Prelude.Int]));

{-# NEED findIndex #-}
findIndex{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> (Prelude.Maybe Prelude.Int)));

{-# NEED count #-}
count{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> Prelude.Int));

{-# NEED elemIndices #-}
elemIndices{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> [Prelude.Int]));

{-# NEED elemIndexEnd #-}
elemIndexEnd{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> (Prelude.Maybe Prelude.Int)));

{-# NEED elemIndex #-}
elemIndex{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> (Prelude.Maybe Prelude.Int)));

{-# NEED index #-}
index{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Prelude.Int -> NHC.FFI.Word8));

{-# NEED intercalate #-}
intercalate{-# 1 #-}::(Data.ByteString.Internal.ByteString -> ([Data.ByteString.Internal.ByteString] -> Data.ByteString.Internal.ByteString));

{-# NEED groupBy #-}
groupBy{-# 2 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> Prelude.Bool)) -> (Data.ByteString.Internal.ByteString -> [Data.ByteString.Internal.ByteString]));

{-# NEED group #-}
group{-# 1 #-}::(Data.ByteString.Internal.ByteString -> [Data.ByteString.Internal.ByteString]);

{-# NEED split #-}
split{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> [Data.ByteString.Internal.ByteString]));

{-# NEED splitWith #-}
splitWith{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> [Data.ByteString.Internal.ByteString]));

{-# NEED spanEnd #-}
spanEnd{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED span #-}
span{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED breakEnd #-}
breakEnd{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED breakByte #-}
breakByte{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED break #-}
break{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED dropWhile #-}
dropWhile{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED takeWhile #-}
takeWhile{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED splitAt #-}
splitAt{-# 2 #-}::(Prelude.Int -> (Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString,Data.ByteString.Internal.ByteString)));

{-# NEED drop #-}
drop{-# 2 #-}::(Prelude.Int -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED take #-}
take{-# 2 #-}::(Prelude.Int -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED unfoldrN #-}
unfoldrN{-# 3 #-}::(Prelude.Int -> ((a -> (Prelude.Maybe (NHC.FFI.Word8,a))) -> (a -> (Data.ByteString.Internal.ByteString,(Prelude.Maybe a)))));

{-# NEED unfoldr #-}
unfoldr{-# 1 #-}::((a -> (Prelude.Maybe (NHC.FFI.Word8,a))) -> (a -> Data.ByteString.Internal.ByteString));

{-# NEED replicate #-}
replicate{-# 2 #-}::(Prelude.Int -> (NHC.FFI.Word8 -> Data.ByteString.Internal.ByteString));

{-# NEED scanr1 #-}
scanr1{-# 2 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED scanr #-}
scanr{-# 3 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString)));

{-# NEED scanl1 #-}
scanl1{-# 2 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED scanl #-}
scanl{-# 3 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString)));

{-# NEED mapAccumR #-}
mapAccumR{-# 3 #-}::((a -> (NHC.FFI.Word8 -> (a,NHC.FFI.Word8))) -> (a -> (Data.ByteString.Internal.ByteString -> (a,Data.ByteString.Internal.ByteString))));

{-# NEED mapAccumL #-}
mapAccumL{-# 3 #-}::((a -> (NHC.FFI.Word8 -> (a,NHC.FFI.Word8))) -> (a -> (Data.ByteString.Internal.ByteString -> (a,Data.ByteString.Internal.ByteString))));

{-# NEED minimum #-}
minimum{-# 1 #-}::(Data.ByteString.Internal.ByteString -> NHC.FFI.Word8);

{-# NEED maximum #-}
maximum{-# 1 #-}::(Data.ByteString.Internal.ByteString -> NHC.FFI.Word8);

{-# NEED all #-}
all{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> Prelude.Bool));

{-# NEED any #-}
any{-# 2 #-}::((NHC.FFI.Word8 -> Prelude.Bool) -> (Data.ByteString.Internal.ByteString -> Prelude.Bool));

{-# NEED concatMap #-}
concatMap{-# 1 #-}::((NHC.FFI.Word8 -> Data.ByteString.Internal.ByteString) -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED concat #-}
concat{-# 1 #-}::([Data.ByteString.Internal.ByteString] -> Data.ByteString.Internal.ByteString);

{-# NEED foldr1' #-}
foldr1'{-# 2 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (Data.ByteString.Internal.ByteString -> NHC.FFI.Word8));

{-# NEED foldr1 #-}
foldr1{-# 2 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (Data.ByteString.Internal.ByteString -> NHC.FFI.Word8));

{-# NEED foldl1' #-}
foldl1'{-# 2 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (Data.ByteString.Internal.ByteString -> NHC.FFI.Word8));

{-# NEED foldl1 #-}
foldl1{-# 2 #-}::((NHC.FFI.Word8 -> (NHC.FFI.Word8 -> NHC.FFI.Word8)) -> (Data.ByteString.Internal.ByteString -> NHC.FFI.Word8));

{-# NEED foldr' #-}
foldr'{-# 3 #-}::((NHC.FFI.Word8 -> (a -> a)) -> (a -> (Data.ByteString.Internal.ByteString -> a)));

{-# NEED foldr #-}
foldr{-# 3 #-}::((NHC.FFI.Word8 -> (a -> a)) -> (a -> (Data.ByteString.Internal.ByteString -> a)));

{-# NEED foldl' #-}
foldl'{-# 0 #-}::((a -> (NHC.FFI.Word8 -> a)) -> (a -> (Data.ByteString.Internal.ByteString -> a)));

{-# NEED foldl #-}
foldl{-# 3 #-}::((a -> (NHC.FFI.Word8 -> a)) -> (a -> (Data.ByteString.Internal.ByteString -> a)));

{-# NEED transpose #-}
transpose{-# 1 #-}::([Data.ByteString.Internal.ByteString] -> [Data.ByteString.Internal.ByteString]);

{-# NEED intersperse #-}
intersperse{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED reverse #-}
reverse{-# 1 #-}::(Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString);

{-# NEED map #-}
map{-# 2 #-}::((NHC.FFI.Word8 -> NHC.FFI.Word8) -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED append #-}
append{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED init #-}
init{-# 1 #-}::(Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString);

{-# NEED last #-}
last{-# 1 #-}::(Data.ByteString.Internal.ByteString -> NHC.FFI.Word8);

{-# NEED uncons #-}
uncons{-# 1 #-}::(Data.ByteString.Internal.ByteString -> (Prelude.Maybe (NHC.FFI.Word8,Data.ByteString.Internal.ByteString)));

{-# NEED tail #-}
tail{-# 1 #-}::(Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString);

{-# NEED head #-}
head{-# 1 #-}::(Data.ByteString.Internal.ByteString -> NHC.FFI.Word8);

{-# NEED snoc #-}
snoc{-# 2 #-}::(Data.ByteString.Internal.ByteString -> (NHC.FFI.Word8 -> Data.ByteString.Internal.ByteString));

{-# NEED cons #-}
cons{-# 2 #-}::(NHC.FFI.Word8 -> (Data.ByteString.Internal.ByteString -> Data.ByteString.Internal.ByteString));

{-# NEED length #-}
length{-# 1 #-}::(Data.ByteString.Internal.ByteString -> Prelude.Int);

{-# NEED null #-}
null{-# 1 #-}::(Data.ByteString.Internal.ByteString -> Prelude.Bool);

{-# NEED unpack #-}
unpack{-# 1 #-}::(Data.ByteString.Internal.ByteString -> [NHC.FFI.Word8]);

{-# NEED pack #-}
pack{-# 1 #-}::([NHC.FFI.Word8] -> Data.ByteString.Internal.ByteString);

{-# NEED singleton #-}
singleton{-# 1 #-}::(NHC.FFI.Word8 -> Data.ByteString.Internal.ByteString);
interface NHC.FFI
{-# NEED Word8 #-}
data Word8;
interface ! Data.ByteString
{-# NEED empty #-}
empty{-# 0 #-}::Data.ByteString.Internal.ByteString;
interface ! Data.ByteString.Internal
{-# NEED ByteString #-}
data ByteString;
}
