			Introduction.

These are implementation notes for nhc98 - a compiler for Haskell'98,
written in Haskell'98.

History.

Nhc originated in the spring of 1993 as "nhc12", a compiler for a subset
of the then-current language version, 1.2.  It was written by Niklas
Rojemo, who wanted a Haskell compiler for his Acorn A5000 machine which
had only 4Mb of memory.  The only other system that could fit on such a
small machine at that time was Gofer (now superseded by Hugs), and
because it is written in C, in Niklas's view it was not so much fun to
play with as a compiler written in Haskell itself.

Since then, nhc12 has become nhc13, then nhc98, as the Haskell language
standard has moved onwards through versions 1.3, 1.4, and 98.  It is now
no longer "Nearly a Haskell Compiler", but just "aNother Haskell
Compiler", as it no longer compiles a subset of the language, but deals
with the full standard.  However, it has retained its focus on small
memory usage, both during compilation and in the compiled code it
produces.

Summary

Nhc98 is written in Haskell with a small run-time system in C.  It can
currently re-compile itself in about 4-6Mb of memory.  It can also be
built using any of the other available Haskell compilers, hbc or ghc.
It compiles to bytecode, which is interpreted at runtime by the RTS.
This means that the code it produces is slower than the other compilers,
but the aim is to produce faster code than Hugs, at which it succeeds.
Compilation times however depend entirely on which compiler nhc98 was
built with - a self-compiled nhc98 is slowish, but an hbc-compiled
or ghc-compiled nhc98 is pretty fast, certainly much faster than ghc,
but a bit slower than hbc.

Nhc98 also incorporates advanced heap profiling facilities.  Heap
profiling is very useful for detecting space leaks in programs, and we
include various types of profile: producer, construction, lifetime,
retainer, and biographical.  Even users with lots of memory can find
a use for nhc98's heap profiling capabilities.  Retainer information
is good for tuning up programs, and lifetime profiles can help to decide
whether generational garbage collection could be advantageous.

Structure

Nhc98 is a shell-script driver which calls the compiler proper,
nhc98comp.  The bytecodes generated by nhc98comp are stored either as
assembler macros or ANSI-C arrays, which makes it easy to cross-compile
with nhc98, and to bootstrap the compiler itself onto new machines.  The
differences between target machines are resolved by feeding the bytecode
assembly macros (or ANSI-C code) through the C pre-processor before
creating the true object files.

